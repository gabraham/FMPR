
graph.sqr <- function(R, threshold=NA) 
{
   s <- sign(R) * R^2
   diag(s) <- 0
   s
}

graph.ind <- function(R, threshold)
{
   s <- sign(R) * (abs(R) > threshold)
   diag(s) <- 0
   s
}

graph.abs <- function(R, threshold=NA)
{
   diag(R) <- 0
   R
}

# Wrappers for calling lasso and fmpr

# lambda1: scalar or K-vector
# lambda2: scalar or K-vector
# lambda3: scalar 
fmpr <- function(X, Y, lambda1=0, lambda2=0, lambda3=0, G=NULL,
      maxiter=1e5, eps=1e-8, verbose=FALSE, simplify=FALSE,
      sparse=TRUE, nzmax=NULL)
{
   p <- ncol(X)
   Y <- cbind(Y)
   K <- ncol(Y)

   if(nrow(X) != nrow(Y))
      stop("dimensions of X and Y don't agree")

   #if(length(lambda1) == 1)
   #   lambda1 <- rep(lambda1, K)
   
   #if(length(lambda2) == 1)
   #   lambda2 <- rep(lambda2, K)

   if(is.null(G))
      G <- matrix(0, K, K)

   #if(type == "threshold") {
   #   fn <- "fmpr_threshold"
   #   g <- as.integer(G)
   #} else {
      fn <- "fmpr_weighted"
      g <- as.numeric(G)
   #}

   B <- foreach(i=seq(along=lambda1)) %:% 
      foreach(j=seq(along=lambda2)) %:%
	 foreach(k=seq(along=lambda3)) %dopar% {
	    # fmpr expects l1/l2/l3 to be a vector of length K,
	    # allowing for a different penalty for each task, but we
	    # don't use this feature here, we use the same penalty for all
	    # tasks
	    if(verbose)
	       cat("\t", i, j, k, "\n")
	    r <- .C(fn, as.numeric(X), as.numeric(Y), 
	       numeric(p * K), nrow(X), ncol(X), K,
       	       as.numeric(rep(lambda1[i], K)),
	       as.numeric(rep(lambda2[j], K)),
	       as.numeric(rep(lambda3[k], K)),
       	       g, as.integer(maxiter),
       	       as.double(eps), as.integer(verbose), integer(1),
	       integer(1), integer(1)
	    )
	    status <- r[[14]]
	    if(!status) {
	       warning("fmpr failed to converge within ",
	          maxiter, " iterations")
	    } else if(verbose) {
	       cat("converged in", r[[15]], "iterations",
		  "with", r[[16]], "active variables\n\n")
	    }
	       
	    m <- matrix(r[[3]], p, K)

	    if(sparse) {
	       w <- which(m != 0, arr.ind=TRUE)
	       sparseMatrix(i=w[,1], w[,2], x=m[w], dims=c(p, K))
	    } else m
   }

   if(simplify && length(lambda1) == 1 
      && length(lambda2) == 1 
      && length(lambda3) == 1) {
      B[[1]][[1]][[1]]
   } else {
      B
   }
}

#fmpr.warm <- function(X, Y, lambda1=0, lambda2=0, lambda3=0, G=NULL,
#      maxiter=1e5, eps=1e-8, verbose=FALSE, simplify=FALSE,
#      sparse=TRUE)
#{
#   p <- ncol(X)
#   Y <- cbind(Y)
#   K <- ncol(Y)
#
#   #if(length(lambda1) == 1)
#   #   lambda1 <- rep(lambda1, K)
#   
#   #if(length(lambda2) == 1)
#   #   lambda2 <- rep(lambda2, K)
#
#   fn <- "fmpr_threshold_warm"
#
#   if(is.null(G))
#      G <- matrix(0, K, K)
#
#   g <- as.integer(G)
#   
#
#   #if(type == "threshold") {
#   #   fn <- "fmpr_threshold"
#   #   g <- as.integer(G)
#   #} else {
#   #   fn <- "fmpr_weighted"
#   #   g <- as.numeric(G)
#   #}
#
#   if(sparse) {
#      B0 <- sparseMatrix(i={}, j={}, dims=c(p, K))
#      LP0 <- sparseMatrix(i={}, j={}, dims=c(N, K))
#   } else {
#      B0 <- matrix(0, p, K)
#      LP0 <- matrix(0, N, K)
#   }
#
#   LP <- lapply(seq(along=lambda1), function(i) LP0)
#
#   # Assumes that lambda2, lambda3 are sorted in
#   # increasing order, and that lambda1 is in decreasing order
#   B <- foreach(i=seq(along=lambda1)) %:%
#      foreach(j=seq(along=lambda2)) %:%
#	 foreach(k=seq(along=lambda3)) %dopar% {
#
#	    if(i == 1) {
#      	       Bt <- numeric(p * K)
#      	       LPt <- numeric(N * K) 
#      	    } else {
#      	       Bt <- as.matrix(B[[i-1]][[1]][[1]])
#      	       LPt <- as.matrix(LP[[i-1]])
#      	    }
#
#	    # fmpr expects l1/l2/l3 to be a vector of length K,
#	    # allowing for a different penalty for each task, but we
#	    # don't use this feature here, we use the same penalty for all
#	    # tasks
#	    r <- .C(fn, as.numeric(X), as.numeric(Y), 
#	       as.numeric(Bt), as.numeric(LPt), nrow(X), ncol(X), K,
#       	       as.numeric(rep(lambda1[i], K)),
#	       as.numeric(rep(lambda2[j], K)),
#	       as.numeric(rep(lambda3[k], K)),
#       	       g, as.integer(maxiter),
#       	       as.double(eps), as.integer(verbose), integer(1),
#	       integer(1), integer(1)
#	    )
#	    status <- r[[15]]
#	    numactive <- r[[17]]
#	    if(!status) {
#	       warning("fmpr failed to converge within ",
#	          maxiter, " iterations")
#	    } else if(verbose) {
#	       cat("converged in", r[[16]], "iterations with",
#		     numactive, "active variables\n\n")
#	    }
#	       
#	    m <- matrix(r[[3]], p, K)
#
#	    if(sparse) {
#	       w <- which(m != 0, arr.ind=TRUE)
#	       sparseMatrix(i=w[,1], w[,2], x=m[w], dims=c(p, K))
#	    } else m
#   }
#
#   if(simplify && length(lambda1) == 1 
#      && length(lambda2) == 1 
#      && length(lambda3) == 1) {
#      B[[1]][[1]][[1]]
#   } else {
#      B
#   }
#}

lasso <- function(X, y, lambda1=0,
      maxiter=1e5, eps=1e-8, verbose=FALSE)
{
   p <- ncol(X)

   sapply(lambda1, function(l) {
      r <- .C("lasso", as.numeric(X), as.numeric(y), numeric(p), 
         nrow(X), ncol(X), as.numeric(l),
         as.integer(maxiter), as.double(eps),
         as.integer(verbose)
      )
      matrix(r[[3]], p)
   })
}

# Can handle ncol(Y) > 1
ridge <- function(X, Y, lambda2=0)
{
   Y <- cbind(Y)
   XX <- crossprod(X)
   XY <- crossprod(X, Y)
   K <- ncol(Y)
   p <- ncol(X)
   l <- lapply(lambda2, function(l) {
      b <- try(qr.solve(XX + diag(p) * l, XY), silent=TRUE)
      if(is(b, "try-error")) {
	 matrix(0, p, K)
      } else {
	 b
      }
   })
   l
}

# zero mean, unit norm (not unit variance)
standardise <- function(x)
{
   x1 <- sweep(x, 2, colMeans(x))
   v <- apply(x1, 2, function(z) sqrt(sum(z^2)))
   s <- sweep(x1, 2, v, FUN="/")
   s[is.na(s)] <- 0
   s
}

# Returns the maximal l1 penalty for each task, i.e., the smallest l1 penalty
# that makes all the weights zero.
maxlambda1 <- function(X, Y)
{
   Y <- cbind(Y)
   r <- .C("maxlambda1", as.numeric(X), as.numeric(Y),
      numeric(ncol(Y)), nrow(X), ncol(X), ncol(Y))
   r[[3]]
}

# Converts an N by p matrix into a block-diagonal N*K by p*K matrix
blockX <- function(X, p, K)
{
   N <- nrow(X)
   
   Xblock <- matrix(0, N * K, p * K) 
   s1 <- seq(1, N * K, N)
   s2 <- seq(1, p * K, p)

   for(i in 1:K)
   {
      j <- s1[i]:(s1[i] + N - 1)
      k <- s2[i]:(s2[i] + p - 1)
      Xblock[j, k] <- X
   }

   Xblock
}

# Makes the edges by vertices matrix for SPG
# Same as gennetwork.m
# 
# cortype: 0: thresholding to binary values
#          1: |R|
#          2: R^2
gennetwork <- function(Y, corthresh=0.5, cortype=1)
{
   R <- cor(Y)

   R[abs(R) < corthresh] <- 0

   K <- ncol(Y)
   nV <- K
   UR <- R
   UR[lower.tri(UR)] <- 0
   diag(UR) <- 0
   
   W <- if(cortype == 0) {
      (abs(UR) > corthresh) + 0
   } else if(cortype == 1) {
      abs(UR)
   } else if(cortype == 2) {
      UR^2
   } else {
      stop("unknown cortype:", cortype)
   }

   nzUR <- which(UR != 0)
   E <- which(UR != 0, arr.ind=TRUE)
   Ecoef <- W[nzUR]
   Esign <- sign(R[nzUR])
   nE <- nrow(E)
   C_I <- c(1:nE, 1:nE)
   C_J <- as.numeric(E)
   C_S <- cbind(Ecoef, -Ecoef * Esign)
   C <- matrix(0, nE, nV)
   C[cbind(C_I, C_J)] <- C_S
   C
}

spg <- function(X, Y, C, lambda, gamma, tol=1e-4, mu=1e-4, maxiter=1e4,
      simplify=FALSE, verbose=FALSE)
{
   K <- ncol(Y)
   N <- nrow(Y)
   p <- ncol(X)

   if(length(C) == 0)
      C <- matrix(0, 1, 1)

   XX <- crossprod(X)
   XY <- crossprod(X, Y)
   CNorm <- 2 * max(colSums(C^2))
   C0 <- C
   L0 <- eigen(XX)$values[1]

   cat("CNorm:", CNorm, "\n")

   B <- foreach(i=seq(along=lambda)) %:% 
      foreach(j=seq(along=gamma)) %dopar% {
	 L <- L0 + gamma[j]^2 * CNorm / mu
	 C <- gamma[j] * C0

	 if(verbose)
	    cat("spg gamma:", gamma[j], "lambda:", lambda[i], "\n")

	 r <- .C("spg_core",
   	    as.numeric(XX), as.numeric(XY),
   	    as.numeric(X), as.numeric(Y),
   	    as.integer(N), as.integer(p), as.integer(K),
   	    numeric(p * K),
   	    as.numeric(C), as.integer(nrow(C)), as.numeric(L), 
   	    as.numeric(gamma[j]), as.numeric(lambda[i]),
   	    as.numeric(tol), as.numeric(mu), as.integer(maxiter),
   	    as.integer(verbose), integer(1)
   	 )
   	 niter <- r[[18]]

	 matrix(r[[8]], p, K)
   }
   
   if(simplify
      && length(lambda) == 1 
      && length(gamma) == 1) {
      B[[1]][[1]]
   } else {
      B
   }
}

